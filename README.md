# python-coding

This repository contains questions and the solutions for it.
The questions have been taken from various sources and the difficulty level can vary between easy, medium or hard.

**The questions can be divided into various subtopics.**

### Conditionals and Loops
[Fibonacci](https://github.com/karanmalh0tra/python-coding/tree/master/NthFibonacciNumber) To find the Nth number in the fibonacci list

[Reverse of a Number](https://github.com/karanmalh0tra/python-coding/tree/master/ReverseOfANumber) has the solution to reverse a number.

### Patterns

[Pyramid Number Pattern](https://github.com/karanmalh0tra/python-coding/tree/master/PyramidNumberPattern) are numbers in the shape of a Pyramid.

[Alpha Pattern](https://github.com/karanmalh0tra/python-coding/blob/master/AlphaPattern) are patterns that are made with alphabets instead of symbols or integers.

[Arrow Pattern](https://github.com/karanmalh0tra/python-coding/tree/master/ArrowPattern) is an arrow shaped pattern built using *

[Zeros and Stars Pattern](https://github.com/karanmalh0tra/python-coding/tree/master/ZerosAndStarsPattern) are where you might need to think a tad bit harder than the usual patterns.

### Searching and Sorting
[Binary Search](https://github.com/karanmalh0tra/python-coding/tree/master/BinarySearch) is one of the most commonly used search algorithm which needs a sorted array to perform the search algorithm.

[Bubble Sort](https://github.com/karanmalh0tra/python-coding/tree/master/BubbleSort) puts the largest element at the end in each round of sort that it performs.

[Selection Sort](https://github.com/karanmalh0tra/python-coding/tree/master/SelectionSort) finds the minimum element from the unsorted part and puts it in the sorted part.

[Insertion Sort](https://github.com/karanmalh0tra/python-coding/tree/master/InsertionSort) keeps putting an element from the unsorted list to the sorted list.

[Merge Two Sorted Arrays](https://github.com/karanmalh0tra/python-coding/tree/master/MergeTwoSortedArrays) can be solved by using the fundamentals of sorting algorithms.

[PushZerosToEnd](https://github.com/karanmalh0tra/python-coding/tree/master/PushZerosToEnd) requires you to push the zeros present in the array towards the end without using an extra array to do so.

[RotateArray](https://github.com/karanmalh0tra/python-coding/tree/master/RotateArray) Shift the array to the left by the number entered by the user.

[Sort012](https://github.com/karanmalh0tra/python-coding/tree/master/Sort012) Sort an array consisting of 0s 1s and 2s in only one scan and on the same array.

[SumOfTwoArrays](https://github.com/karanmalh0tra/python-coding/tree/master/SumOfTwoArrays) is the actual addition of units, tenths, hundreds places of an array.

[Merge Sort](https://github.com/karanmalh0tra/python-coding/tree/master/MergeSort) sorts the array via recursion and is faster than Bubble Sort and Insertion Sort. Since Recursion is used, the same code will be present under Recursion topic as well.

[Quick Sort](https://github.com/karanmalh0tra/python-coding/tree/master/QuickSort) sorts the array via recursion and is faster than Bubble Sort and Insertion Sort. It uses lesser space than Merge Sort. Since Recursion is used, the same code will be present under Recursion topic as well.


### Recursions

[PowerOfANumber](https://github.com/karanmalh0tra/python-coding/tree/master/PowerOfANumber) finds the power of a number through recursion.

[isListSorted](https://github.com/karanmalh0tra/python-coding/tree/master/isListSorted) checks if the list is sorted or not via recursion.

[RemoveDuplicatesRecursively](https://github.com/karanmalh0tra/python-coding/tree/master/RemoveDuplicatesRecursively) removes all the duplicates in a string and replaces them with only one instance of it via recursion.

[Merge Sort](https://github.com/karanmalh0tra/python-coding/tree/master/MergeSort) sorts the array via recursion and is faster than Bubble Sort and Insertion Sort. Since this is a sorting algorithm, the same code will be present under Searching and Sorting topic as well.

[Quick Sort](https://github.com/karanmalh0tra/python-coding/tree/master/QuickSort) sorts the array via recursion and is faster than Bubble Sort and Insertion Sort. It uses lesser space than Merge Sort. Since this is a sorting algorithm, the same code will be present under Searching and Sorting topic as well.

[Tower of Hanoi](https://github.com/karanmalh0tra/python-coding/tree/master/TowerOfHanoi) is difficult to understand but easy to implement via recursion.


### Time Complexities

[Intersection of Two Arrays](https://github.com/karanmalh0tra/python-coding/tree/master/IntersectonOfTwoArrays) where the intersection of two unsorted arrays are printed keeping time complexity in mind. Brute Force => O(n^2). This solution => O(n* log n)

[Equilibrium Index](https://github.com/karanmalh0tra/python-coding/tree/master/ArrayEquilibriumIndex) returns the index of the array from where the left part and the right part of the array is equal. Brute Force => O(n^2). This solution => O(n)

[Pair Sum In Array](https://github.com/karanmalh0tra/python-coding/tree/master/PairSumInArray) returns the pair of numbers in array that sum up to the input provided. Brute Force => O(n^2). This solution Ideal => O(n). Worst Case => O(n^2). The worst case is only because the problem statement asks us to repeat the output multiple times. For only one pair of similar numbers, using dictionary would help solve this in O(n).

[Triplet Sum](https://github.com/karanmalh0tra/python-coding/tree/master/TripletSum) returns the pair of numbers in array that sum up to the input provided. Brute Force => O(n^3). This solution Ideal => O(n^2). Worst Case => O(n^3). The worst case is only because the problem statement asks us to repeat the output multiple times. For only one triplet of similar numbers, using dictionary would help solve this in O(n^2).

### Linked List

[Implementation of Linked List](https://github.com/karanmalh0tra/python-coding/tree/master/LinkedListImplementation) has the code to implement a linked list. Ask the user for input in a single line and also print the linked list.

### Stack

[Implementation of Stack](https://github.com/karanmalh0tra/python-coding/tree/master/StackImplementation) has the code to implement stack using Array and LinkedList. The functionalities of stack that are included here are push, pop, top, size and isEmpty.
Other coding questions that utilise stack implementation would also be present in here.

### Queue

[Implementation of Queue](https://github.com/karanmalh0tra/python-coding/tree/master/QueueImplementation) has the code to implement queue using Array and Linked List. The functionalities of queue that are included here are enqueue, dequeue, front, size and isEmpty.

### Binary Trees

[Implementation of Binary Trees](https://github.com/karanmalh0tra/python-coding/tree/master/BinaryTreeImplementation) has the code to implement binary trees. Most of the tree problems are to be solved via recursion since a tree always consist of nodes that are trees themselves.

### Dictionaries and Hash Maps
Access and Insert should be very fast
Use List or Array (Bucket Array)
Key -> Hash Function -> Integer
Hash Function?
  1. HashCode => "abc" => hashcode => 10000
  2. Compression Function(to fit within bucket size) eg. %bucketsize
#### HASHCODES.
 integer -> hashcode -> same integer
 string -> Number base p eg. 10^2*a + 10*b + 1*c (p = 10. ideally prime)
Python has inbuilt hash funtion. hash()
##### Collision Handling
  1. Closed Hashing(Store in the same index. maintain LL)
  2. Open Addressing(h.f(a) + f(i))
##### Probing
linear probing f(i) = i
Quadratic Probing f(i) = i^2
Double Hashing f(i) = i * h'(a)
Note: Seperate Chaining Works Absolutely Fine(easy to implement and understand)

#### Load Factor
Load Factor is the ratio of number of indexes / bucket size.
Keeping it lesser than 0.7 helps maintain a time complexity of O(1)
However, as soon as the loadFactor is greater than 0.7:
  1. Bucket Size is increased by 2x
  2. Rehashing is done and elements are entered in the new bucket.

[Implementation of Hash Maps](https://github.com/karanmalh0tra/python-coding/tree/master/Dictionaries&HashMaps) has the code to implement hash maps.


### Huffman Coding

Huffman coding utilises various data structures and is thus a good problem to solve while learning about data structures and algorithms.
I utilised lists, Binary Trees, Min Heap to implement huffman coding.
If you wish to use the same, ensure to change the filepath in the code to the file you want to use the script with.

How Huffman Compression works?
  1. Read Text from the File
  2. Make a dictionary with characters and its frequency
  3. Construct a Min Heap with the help of the dictionary. Utilise Binary Trees here.
  4. Construct a Binary Tree from the Min Heap.
  5. Construct the codes dictionary from the binary tree made above. (also prepare a reverse code dictionar from decompression)
  6. Create encoded texts using the codes dictionary.
  7. Have a padding to these encoded texts.
  8. Convert the padded text to bytes.
  9. Write the bytes to a ".bin" extension file.

[Huffman Coding](https://github.com/karanmalh0tra/python-coding/tree/master/HuffmanCoding) has the implementation of huffman coding algorithm.


### Graphs

Graphs  have vertices and edge
v1 ------edge---- v2
Degree => Edges going through a vertex
Path => traversal is possible via edges and vertices.
Connected Graph => if theres a path between any two vertices
Connected Component(Sub-graph) => Disconnected graph can have connected components

Tree is a connected graph with no cycle.

Minimum Edges in a Graph = 0
Minimum Edges in a Connected Graph for n vertices = n-1
Minimum Edges in a Connected Graph for n vertices = (n*(n-1))/2

Graph Implementation

Adjacency Matrix (if more number of vertices)
 - maintain only vertices array
 - Space Complexity O(n^2) [ n * n matrix]
 - check if edge is there or not O(1) adj[v1][v2]
